---
sidebar: aiSidebar
title: Power（规范驱动编程）
---

# Power（规范驱动编程能力）

## 概述

**Power** 是由 **Kiro** 提出的一个概念，用于衡量 **AI 工具理解复杂规范并生成符合规范代码的能力**。在 Spec-Driven Development（规范驱动开发）的语境下，Power 指的是 AI 将非结构化的需求描述转换为结构化的技术规范，并最终生成可执行代码的能力。

> **核心理念**：Power = 规范理解能力 × 代码生成能力 × 约束遵循能力

---

## Power 的定义

### 1. 基本概念

**Power** 是 AI 编程工具的核心能力指标：

```
┌─────────────────────────────────────────────────────────┐
│                    Power 的构成                          │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  ┌──────────────────────────────────────────────┐      │
│  │         规范理解 (Spec Understanding)          │      │
│  │         理解自然语言需求 → 结构化规范          │      │
│  └──────────────────────────────────────────────┘      │
│                         ↓                               │
│  ┌──────────────────────────────────────────────┐      │
│  │         规范生成 (Spec Generation)             │      │
│  │         生成 API、数据模型、UI 规范             │      │
│  └──────────────────────────────────────────────┘      │
│                         ↓                               │
│  ┌──────────────────────────────────────────────┐      │
│  │         代码实现 (Code Implementation)         │      │
│  │         根据规范生成符合要求的代码              │      │
│  └──────────────────────────────────────────────┘      │
│                         ↓                               │
│  ┌──────────────────────────────────────────────┐      │
│  │         约束遵循 (Constraint Adherence)       │      │
│  │         遵循编码规范、技术约束、业务规则        │      │
│  └──────────────────────────────────────────────┘      │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 2. Power 的维度

| 维度 | 说明 | 评估标准 |
| ---- | ---- | -------- |
| **理解力** | 理解复杂需求的能力 | 能否准确提取关键信息 |
| **结构化** | 生成结构化规范的能力 | 规范是否完整、一致 |
| **实现力** | 生成可执行代码的能力 | 代码是否可用、正确 |
| **遵循力** | 遵循约束的能力 | 是否符合规范要求 |
| **一致性** | 多次输出的稳定性 | 相同输入是否得到相似结果 |

---

## Power 的级别

### Level 0: 无规范能力

```
特征:
- 无法理解结构化需求
- 只能处理简单指令
- 生成代码需要大量人工修改

示例:
输入: "写个登录"
输出: [基础代码，但缺类型、验证、错误处理]
```

### Level 1: 基础规范理解

```
特征:
- 能理解简单的结构化需求
- 能生成基本的代码框架
- 需要人工补充细节

示例:
输入: "用 React + TypeScript 写登录，包含邮箱和密码"
输出: [带类型的组件，但可能缺验证逻辑]
```

### Level 2: 中级规范能力

```
特征:
- 能理解多层级规范
- 能生成完整的 API 规范
- 代码基本可用，需少量调整

示例:
输入: "用户登录功能，需验证、错误处理、JWT"
输出: [完整的登录流程，含前后端]
```

### Level 3: 高级规范能力

```
特征:
- 能理解复杂的业务规范
- 能生成前后端联调代码
- 包含测试和文档

示例:
输入: "完整的用户认证系统（注册、登录、登出、权限）"
输出: [全栈代码 + API 文档 + 测试用例]
```

### Level 4: 专家级规范能力

```
特征:
- 能理解企业级规范
- 自动处理边界情况和异常
- 生成生产级代码

示例:
输入: "电商订单系统（含支付、库存、物流、退款）"
输出: [微服务架构 + 数据库设计 + 完整实现]
```

---

## Power 的评估

### 1. 评估维度

```markdown
## Power 评估卡

### 需求理解
- [ ] 能识别核心功能
- [ ] 能识别非功能需求（性能、安全）
- [ ] 能识别依赖和约束
- [ ] 能识别边界条件

### 规范生成
- [ ] API 规范完整性
- [ ] 数据模型合理性
- [ ] 错误处理覆盖
- [ ] 验证规则完整

### 代码质量
- [ ] 语法正确性
- [ ] 类型安全性
- [ ] 代码可读性
- [ ] 最佳实践遵循

### 约束遵循
- [ ] 技术栈约束
- [ ] 编码规范约束
- [ ] 业务规则约束
- [ ] 性能约束
```

### 2. 评分标准

| 分数 | 描述 |
| ---- | ---- |
| **0-20** | 几乎无法理解规范 |
| **20-40** | 能理解简单规范，代码需大量修改 |
| **40-60** | 能理解中等规范，代码需少量修改 |
| **60-80** | 能理解复杂规范，代码基本可用 |
| **80-100** | 完全理解规范，生成生产级代码 |

### 3. 自动化评估

```python
# Power 评估脚本示例
def evaluate_power(ai_tool, test_cases):
    scores = []
    for case in test_cases:
        # 生成规范
        spec = ai_tool.generate_spec(case.requirement)

        # 生成代码
        code = ai_tool.generate_code(spec)

        # 评估
        score = {
            "spec_completeness": check_spec_completeness(spec, case),
            "code_correctness": check_code_correctness(code),
            "constraint_adherence": check_constraints(code, case.constraints),
            "test_pass_rate": run_tests(code, case.tests)
        }

        scores.append(score)

    return aggregate_scores(scores)
```

---

## Power 在不同工具中的体现

### 1. Qoder Spec Mode

Qoder 的 **Spec Mode** 专注于 Power 能力：

```
特点:
├── 自然语言 → 结构化规范
├── 规范确认机制
├── 多步骤代码生成
└── 规范可复用

Power 水平: Level 3-4
```

### 2. Cursor Composer

Cursor 的 **Composer** 特性：

```
特点:
├── 自动规划任务步骤
├── 跨文件代码生成
├── 上下文感知
└── 迭代优化

Power 水平: Level 2-3
```

### 3. Claude Code

Claude Code 的 **Plan Mode**：

```
特点:
├── 深度代码理解
├── 分步实施计划
├── 人工确认机制
└── 详细说明

Power 水平: Level 3
```

### 4. GitHub Copilot Workspace

Copilot 的 **Workspace**：

```
特点:
├── Issue → Spec → Code 流程
├── 测试生成
├── Pull Request 描述
└── 迭代改进

Power 水平: Level 2-3
```

---

## 提升 Power 的技巧

### 1. 编写更好的规范

#### 使用结构化格式

```markdown
# ❌ 模糊的规范
"做一个用户管理功能"

# ✅ 结构化的规范
## 功能：用户管理

### 需求
- 用户列表（分页、搜索）
- 用户详情
- 创建用户
- 编辑用户
- 删除用户（软删除）

### 字段定义
- id: UUID
- name: 字符串，2-50字符
- email: 邮箱格式，唯一
- role: 枚举（admin, user, guest）
- status: 枚举（active, inactive）
- created_at: 时间戳

### 验证规则
- name 必填
- email 唯一
- role 默认为 user

### API 设计
GET    /api/users      # 列表
GET    /api/users/:id  # 详情
POST   /api/users      # 创建
PUT    /api/users/:id  # 更新
DELETE /api/users/:id  # 删除

### 技术要求
- React + TypeScript
- RESTful API
- 使用 Prisma ORM
```

### 2. 使用模板

```markdown
# 功能规范模板

## 功能概述
[一句话描述]

## 用户故事
作为 [角色]，我想要 [功能]，以便 [目的]

## 验收标准
- [ ] 标准1
- [ ] 标准2

## 技术规范
### 数据模型
### API 接口
### UI 规范

## 非功能需求
### 性能
### 安全
### 兼容性
```

### 3. 渐进式规范

```
第一版（粗略）:
"用户登录功能"

第二版（添加细节）:
"用户登录，邮箱和密码，需要验证"

第三版（完整规范）:
[完整的功能规范，含所有细节]

第四版（迭代优化）:
[基于反馈的优化版本]
```

### 4. 提供示例

```
# 在规范中添加示例

## 输入示例
{
  "email": "user@example.com",
  "password": "SecurePass123"
}

## 输出示例
成功（200）:
{
  "success": true,
  "token": "eyJhbGc...",
  "user": {...}
}

失败（401）:
{
  "success": false,
  "error": "Invalid credentials"
}
```

---

## Power 的局限

### 1. 复杂业务逻辑

```
问题: AI 难以理解复杂的业务规则

解决:
- 分解为多个小功能
- 提供详细规则说明
- 添加决策树/流程图
```

### 2. 隐性知识

```
问题: AI 无法获取团队隐性知识

解决:
- 使用 llms.txt/CLAUDE.md
- 维护项目规范文档
- 建立代码示例库
```

### 3. 上下文限制

```
问题: 大型项目规范超出上下文窗口

解决:
- 分模块编写规范
- 使用 RAG 检索相关规范
- 建立规范层次结构
```

---

## Power 与 Spec-Driven Development

### 关系

```
┌─────────────────────────────────────────────────────────┐
│          Power 在 SDD 中的作用                          │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Spec-Driven Development 流程:                          │
│                                                         │
│  1. 需求 → 规范                        │
│     └── Power 决定转换质量                              │
│                                                         │
│  2. 规范 → 代码 (Spec → Code)                          │
│     └── Power 决定代码质量                              │
│                                                         │
│  3. 代码 → 测试 (Code → Test)                          │
│     └── Power 影响测试覆盖                              │
│                                                         │
│  结论: Power 越高，SDD 效率越高                          │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 最佳实践

1. **高 Power 工具 + 完整规范** = 最佳效果
2. **低 Power 工具 + 简单规范** = 基础自动化
3. **高 Power 工具 + 简单规范** = 过度设计
4. **低 Power 工具 + 复杂规范** = 效果有限

---

## Power 的发展趋势

### 当前状态 (2025)

```
Level 1-2: 主流
- 大多数 AI 编码工具处于这个水平
- 适合简单到中等复杂度任务

Level 3: 先进
- 少数工具达到
- 需要良好的规范编写

Level 4: 探索
- 研究阶段
- 需要更强的模型和更好的工具支持
```

### 未来方向

```
┌─────────────────────────────────────────────────────────┐
│                    Power 的未来                         │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  短期（1-2年）                                           │
│  ├── 更好的规范理解                                      │
│  ├── 更准确的代码生成                                    │
│  └── 更强的约束遵循                                      │
│                                                         │
│  中期（2-3年）                                           │
│  ├── 自动化规范生成                                      │
│  ├── 规范版本管理                                        │
│  └── 团队协作支持                                        │
│                                                         │
│  长期（3-5年）                                           │
│  ├── 自演进规范                                          │
│  ├── 跨项目规范复用                                      │
│  └── 规范市场/交换                                       │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## 参考资源

### 相关文档

- [Spec-Driven Development](./spec-driven-development)
- [Vibe Coding](./vibe-coding)
- [Prompt Engineering](./prompt-engineering)

### 工具

- [Qoder](https://qoder.com) - Spec Mode 支持
- [Cursor](https://cursor.sh) - Composer 功能
- [Claude Code](https://claude.ai/code) - Plan Mode

---

**文档更新时间：2025 年 12 月**
